// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collector.proto

#ifndef PROTOBUF_collector_2eproto__INCLUDED
#define PROTOBUF_collector_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)

namespace lightstep {
namespace collector {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_collector_2eproto();
void protobuf_AssignDesc_collector_2eproto();
void protobuf_ShutdownFile_collector_2eproto();

class Auth;
class Command;
class InternalMetrics;
class KeyValue;
class Log;
class MetricsSample;
class Reference;
class ReportRequest;
class ReportResponse;
class Span;
class SpanContext;
class Tracer;

enum Reference_Relationship {
  Reference_Relationship_CHILD_OF = 0,
  Reference_Relationship_FOLLOWS_FROM = 1,
  Reference_Relationship_Reference_Relationship_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Reference_Relationship_Reference_Relationship_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Reference_Relationship_IsValid(int value);
const Reference_Relationship Reference_Relationship_Relationship_MIN = Reference_Relationship_CHILD_OF;
const Reference_Relationship Reference_Relationship_Relationship_MAX = Reference_Relationship_FOLLOWS_FROM;
const int Reference_Relationship_Relationship_ARRAYSIZE = Reference_Relationship_Relationship_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reference_Relationship_descriptor();
inline const ::std::string& Reference_Relationship_Name(Reference_Relationship value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reference_Relationship_descriptor(), value);
}
inline bool Reference_Relationship_Parse(
    const ::std::string& name, Reference_Relationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reference_Relationship>(
    Reference_Relationship_descriptor(), name, value);
}
// ===================================================================

class SpanContext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.SpanContext) */ {
 public:
  SpanContext();
  virtual ~SpanContext();

  SpanContext(const SpanContext& from);

  inline SpanContext& operator=(const SpanContext& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpanContext& default_instance();

  void Swap(SpanContext* other);

  // implements Message ----------------------------------------------

  inline SpanContext* New() const { return New(NULL); }

  SpanContext* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SpanContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional uint64 trace_id = 1;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // optional uint64 span_id = 2;
  void clear_span_id();
  static const int kSpanIdFieldNumber = 2;
  ::google::protobuf::uint64 span_id() const;
  void set_span_id(::google::protobuf::uint64 value);

  // map<string, string> baggage = 3;
  int baggage_size() const;
  void clear_baggage();
  static const int kBaggageFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      baggage() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_baggage();

  // @@protoc_insertion_point(class_scope:lightstep.collector.SpanContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 trace_id_;
  ::google::protobuf::uint64 span_id_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 >
      SpanContext_BaggageEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > baggage_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static SpanContext* default_instance_;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  enum ValueCase {
    kStringValue = 2,
    kIntValue = 3,
    kDoubleValue = 4,
    kBoolValue = 5,
    kJsonValue = 6,
    VALUE_NOT_SET = 0,
  };

  void Swap(KeyValue* other);

  // implements Message ----------------------------------------------

  inline KeyValue* New() const { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string string_value = 2;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 2;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // optional int64 int_value = 3;
  private:
  bool has_int_value() const;
  public:
  void clear_int_value();
  static const int kIntValueFieldNumber = 3;
  ::google::protobuf::int64 int_value() const;
  void set_int_value(::google::protobuf::int64 value);

  // optional double double_value = 4;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 4;
  double double_value() const;
  void set_double_value(double value);

  // optional bool bool_value = 5;
  private:
  bool has_bool_value() const;
  public:
  void clear_bool_value();
  static const int kBoolValueFieldNumber = 5;
  bool bool_value() const;
  void set_bool_value(bool value);

  // optional string json_value = 6;
  private:
  bool has_json_value() const;
  public:
  void clear_json_value();
  static const int kJsonValueFieldNumber = 6;
  const ::std::string& json_value() const;
  void set_json_value(const ::std::string& value);
  void set_json_value(const char* value);
  void set_json_value(const char* value, size_t size);
  ::std::string* mutable_json_value();
  ::std::string* release_json_value();
  void set_allocated_json_value(::std::string* json_value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:lightstep.collector.KeyValue)
 private:
  inline void set_has_string_value();
  inline void set_has_int_value();
  inline void set_has_double_value();
  inline void set_has_bool_value();
  inline void set_has_json_value();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    ::google::protobuf::int64 int_value_;
    double double_value_;
    bool bool_value_;
    ::google::protobuf::internal::ArenaStringPtr json_value_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Log) */ {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  void Swap(Log* other);

  // implements Message ----------------------------------------------

  inline Log* New() const { return New(NULL); }

  Log* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Log* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* mutable_timestamp();
  ::google::protobuf::Timestamp* release_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // repeated .lightstep.collector.KeyValue keyvalues = 2;
  int keyvalues_size() const;
  void clear_keyvalues();
  static const int kKeyvaluesFieldNumber = 2;
  const ::lightstep::collector::KeyValue& keyvalues(int index) const;
  ::lightstep::collector::KeyValue* mutable_keyvalues(int index);
  ::lightstep::collector::KeyValue* add_keyvalues();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
      mutable_keyvalues();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
      keyvalues() const;

  // @@protoc_insertion_point(class_scope:lightstep.collector.Log)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::Timestamp* timestamp_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue > keyvalues_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static Log* default_instance_;
};
// -------------------------------------------------------------------

class Reference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Reference) */ {
 public:
  Reference();
  virtual ~Reference();

  Reference(const Reference& from);

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reference& default_instance();

  void Swap(Reference* other);

  // implements Message ----------------------------------------------

  inline Reference* New() const { return New(NULL); }

  Reference* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Reference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Reference_Relationship Relationship;
  static const Relationship CHILD_OF =
    Reference_Relationship_CHILD_OF;
  static const Relationship FOLLOWS_FROM =
    Reference_Relationship_FOLLOWS_FROM;
  static inline bool Relationship_IsValid(int value) {
    return Reference_Relationship_IsValid(value);
  }
  static const Relationship Relationship_MIN =
    Reference_Relationship_Relationship_MIN;
  static const Relationship Relationship_MAX =
    Reference_Relationship_Relationship_MAX;
  static const int Relationship_ARRAYSIZE =
    Reference_Relationship_Relationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Relationship_descriptor() {
    return Reference_Relationship_descriptor();
  }
  static inline const ::std::string& Relationship_Name(Relationship value) {
    return Reference_Relationship_Name(value);
  }
  static inline bool Relationship_Parse(const ::std::string& name,
      Relationship* value) {
    return Reference_Relationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .lightstep.collector.Reference.Relationship relationship = 1;
  void clear_relationship();
  static const int kRelationshipFieldNumber = 1;
  ::lightstep::collector::Reference_Relationship relationship() const;
  void set_relationship(::lightstep::collector::Reference_Relationship value);

  // optional .lightstep.collector.SpanContext span_context = 2;
  bool has_span_context() const;
  void clear_span_context();
  static const int kSpanContextFieldNumber = 2;
  const ::lightstep::collector::SpanContext& span_context() const;
  ::lightstep::collector::SpanContext* mutable_span_context();
  ::lightstep::collector::SpanContext* release_span_context();
  void set_allocated_span_context(::lightstep::collector::SpanContext* span_context);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Reference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::lightstep::collector::SpanContext* span_context_;
  int relationship_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static Reference* default_instance_;
};
// -------------------------------------------------------------------

class Span : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Span) */ {
 public:
  Span();
  virtual ~Span();

  Span(const Span& from);

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Span& default_instance();

  void Swap(Span* other);

  // implements Message ----------------------------------------------

  inline Span* New() const { return New(NULL); }

  Span* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Span* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lightstep.collector.SpanContext span_context = 1;
  bool has_span_context() const;
  void clear_span_context();
  static const int kSpanContextFieldNumber = 1;
  const ::lightstep::collector::SpanContext& span_context() const;
  ::lightstep::collector::SpanContext* mutable_span_context();
  ::lightstep::collector::SpanContext* release_span_context();
  void set_allocated_span_context(::lightstep::collector::SpanContext* span_context);

  // optional string operation_name = 2;
  void clear_operation_name();
  static const int kOperationNameFieldNumber = 2;
  const ::std::string& operation_name() const;
  void set_operation_name(const ::std::string& value);
  void set_operation_name(const char* value);
  void set_operation_name(const char* value, size_t size);
  ::std::string* mutable_operation_name();
  ::std::string* release_operation_name();
  void set_allocated_operation_name(::std::string* operation_name);

  // repeated .lightstep.collector.Reference references = 3;
  int references_size() const;
  void clear_references();
  static const int kReferencesFieldNumber = 3;
  const ::lightstep::collector::Reference& references(int index) const;
  ::lightstep::collector::Reference* mutable_references(int index);
  ::lightstep::collector::Reference* add_references();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >*
      mutable_references();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >&
      references() const;

  // optional .google.protobuf.Timestamp start_timestamp = 4;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 4;
  const ::google::protobuf::Timestamp& start_timestamp() const;
  ::google::protobuf::Timestamp* mutable_start_timestamp();
  ::google::protobuf::Timestamp* release_start_timestamp();
  void set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp);

  // optional uint64 duration_micros = 5;
  void clear_duration_micros();
  static const int kDurationMicrosFieldNumber = 5;
  ::google::protobuf::uint64 duration_micros() const;
  void set_duration_micros(::google::protobuf::uint64 value);

  // repeated .lightstep.collector.KeyValue tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::lightstep::collector::KeyValue& tags(int index) const;
  ::lightstep::collector::KeyValue* mutable_tags(int index);
  ::lightstep::collector::KeyValue* add_tags();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
      tags() const;

  // repeated .lightstep.collector.Log logs = 7;
  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 7;
  const ::lightstep::collector::Log& logs(int index) const;
  ::lightstep::collector::Log* mutable_logs(int index);
  ::lightstep::collector::Log* add_logs();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
      mutable_logs();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
      logs() const;

  // @@protoc_insertion_point(class_scope:lightstep.collector.Span)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::lightstep::collector::SpanContext* span_context_;
  ::google::protobuf::internal::ArenaStringPtr operation_name_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference > references_;
  ::google::protobuf::Timestamp* start_timestamp_;
  ::google::protobuf::uint64 duration_micros_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue > tags_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log > logs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static Span* default_instance_;
};
// -------------------------------------------------------------------

class Tracer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Tracer) */ {
 public:
  Tracer();
  virtual ~Tracer();

  Tracer(const Tracer& from);

  inline Tracer& operator=(const Tracer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tracer& default_instance();

  void Swap(Tracer* other);

  // implements Message ----------------------------------------------

  inline Tracer* New() const { return New(NULL); }

  Tracer* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Tracer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 tracer_id = 1;
  void clear_tracer_id();
  static const int kTracerIdFieldNumber = 1;
  ::google::protobuf::uint64 tracer_id() const;
  void set_tracer_id(::google::protobuf::uint64 value);

  // repeated .lightstep.collector.KeyValue tags = 4;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 4;
  const ::lightstep::collector::KeyValue& tags(int index) const;
  ::lightstep::collector::KeyValue* mutable_tags(int index);
  ::lightstep::collector::KeyValue* add_tags();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
      tags() const;

  // @@protoc_insertion_point(class_scope:lightstep.collector.Tracer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 tracer_id_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue > tags_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static Tracer* default_instance_;
};
// -------------------------------------------------------------------

class MetricsSample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.MetricsSample) */ {
 public:
  MetricsSample();
  virtual ~MetricsSample();

  MetricsSample(const MetricsSample& from);

  inline MetricsSample& operator=(const MetricsSample& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetricsSample& default_instance();

  enum ValueCase {
    kIntValue = 2,
    kDoubleValue = 3,
    VALUE_NOT_SET = 0,
  };

  void Swap(MetricsSample* other);

  // implements Message ----------------------------------------------

  inline MetricsSample* New() const { return New(NULL); }

  MetricsSample* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetricsSample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int64 int_value = 2;
  private:
  bool has_int_value() const;
  public:
  void clear_int_value();
  static const int kIntValueFieldNumber = 2;
  ::google::protobuf::int64 int_value() const;
  void set_int_value(::google::protobuf::int64 value);

  // optional double double_value = 3;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 3;
  double double_value() const;
  void set_double_value(double value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:lightstep.collector.MetricsSample)
 private:
  inline void set_has_int_value();
  inline void set_has_double_value();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::int64 int_value_;
    double double_value_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static MetricsSample* default_instance_;
};
// -------------------------------------------------------------------

class InternalMetrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.InternalMetrics) */ {
 public:
  InternalMetrics();
  virtual ~InternalMetrics();

  InternalMetrics(const InternalMetrics& from);

  inline InternalMetrics& operator=(const InternalMetrics& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalMetrics& default_instance();

  void Swap(InternalMetrics* other);

  // implements Message ----------------------------------------------

  inline InternalMetrics* New() const { return New(NULL); }

  InternalMetrics* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternalMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .google.protobuf.Timestamp start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  const ::google::protobuf::Timestamp& start_timestamp() const;
  ::google::protobuf::Timestamp* mutable_start_timestamp();
  ::google::protobuf::Timestamp* release_start_timestamp();
  void set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp);

  // optional uint64 duration_micros = 2;
  void clear_duration_micros();
  static const int kDurationMicrosFieldNumber = 2;
  ::google::protobuf::uint64 duration_micros() const;
  void set_duration_micros(::google::protobuf::uint64 value);

  // repeated .lightstep.collector.Log logs = 3;
  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 3;
  const ::lightstep::collector::Log& logs(int index) const;
  ::lightstep::collector::Log* mutable_logs(int index);
  ::lightstep::collector::Log* add_logs();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
      mutable_logs();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
      logs() const;

  // repeated .lightstep.collector.MetricsSample counts = 4;
  int counts_size() const;
  void clear_counts();
  static const int kCountsFieldNumber = 4;
  const ::lightstep::collector::MetricsSample& counts(int index) const;
  ::lightstep::collector::MetricsSample* mutable_counts(int index);
  ::lightstep::collector::MetricsSample* add_counts();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
      mutable_counts();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
      counts() const;

  // repeated .lightstep.collector.MetricsSample gauges = 5;
  int gauges_size() const;
  void clear_gauges();
  static const int kGaugesFieldNumber = 5;
  const ::lightstep::collector::MetricsSample& gauges(int index) const;
  ::lightstep::collector::MetricsSample* mutable_gauges(int index);
  ::lightstep::collector::MetricsSample* add_gauges();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
      mutable_gauges();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
      gauges() const;

  // @@protoc_insertion_point(class_scope:lightstep.collector.InternalMetrics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::Timestamp* start_timestamp_;
  ::google::protobuf::uint64 duration_micros_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log > logs_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample > counts_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample > gauges_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static InternalMetrics* default_instance_;
};
// -------------------------------------------------------------------

class Auth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Auth) */ {
 public:
  Auth();
  virtual ~Auth();

  Auth(const Auth& from);

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Auth& default_instance();

  void Swap(Auth* other);

  // implements Message ----------------------------------------------

  inline Auth* New() const { return New(NULL); }

  Auth* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Auth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  const ::std::string& access_token() const;
  void set_access_token(const ::std::string& value);
  void set_access_token(const char* value);
  void set_access_token(const char* value, size_t size);
  ::std::string* mutable_access_token();
  ::std::string* release_access_token();
  void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Auth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr access_token_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static Auth* default_instance_;
};
// -------------------------------------------------------------------

class ReportRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.ReportRequest) */ {
 public:
  ReportRequest();
  virtual ~ReportRequest();

  ReportRequest(const ReportRequest& from);

  inline ReportRequest& operator=(const ReportRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportRequest& default_instance();

  void Swap(ReportRequest* other);

  // implements Message ----------------------------------------------

  inline ReportRequest* New() const { return New(NULL); }

  ReportRequest* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lightstep.collector.Tracer tracer = 1;
  bool has_tracer() const;
  void clear_tracer();
  static const int kTracerFieldNumber = 1;
  const ::lightstep::collector::Tracer& tracer() const;
  ::lightstep::collector::Tracer* mutable_tracer();
  ::lightstep::collector::Tracer* release_tracer();
  void set_allocated_tracer(::lightstep::collector::Tracer* tracer);

  // optional .lightstep.collector.Auth auth = 2;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  const ::lightstep::collector::Auth& auth() const;
  ::lightstep::collector::Auth* mutable_auth();
  ::lightstep::collector::Auth* release_auth();
  void set_allocated_auth(::lightstep::collector::Auth* auth);

  // repeated .lightstep.collector.Span spans = 3;
  int spans_size() const;
  void clear_spans();
  static const int kSpansFieldNumber = 3;
  const ::lightstep::collector::Span& spans(int index) const;
  ::lightstep::collector::Span* mutable_spans(int index);
  ::lightstep::collector::Span* add_spans();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >*
      mutable_spans();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >&
      spans() const;

  // optional uint32 timestamp_offset_micros = 5;
  void clear_timestamp_offset_micros();
  static const int kTimestampOffsetMicrosFieldNumber = 5;
  ::google::protobuf::uint32 timestamp_offset_micros() const;
  void set_timestamp_offset_micros(::google::protobuf::uint32 value);

  // optional .lightstep.collector.InternalMetrics internal_metrics = 6;
  bool has_internal_metrics() const;
  void clear_internal_metrics();
  static const int kInternalMetricsFieldNumber = 6;
  const ::lightstep::collector::InternalMetrics& internal_metrics() const;
  ::lightstep::collector::InternalMetrics* mutable_internal_metrics();
  ::lightstep::collector::InternalMetrics* release_internal_metrics();
  void set_allocated_internal_metrics(::lightstep::collector::InternalMetrics* internal_metrics);

  // @@protoc_insertion_point(class_scope:lightstep.collector.ReportRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::lightstep::collector::Tracer* tracer_;
  ::lightstep::collector::Auth* auth_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span > spans_;
  ::lightstep::collector::InternalMetrics* internal_metrics_;
  ::google::protobuf::uint32 timestamp_offset_micros_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static ReportRequest* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  inline Command* New() const { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disable = 1;
  void clear_disable();
  static const int kDisableFieldNumber = 1;
  bool disable() const;
  void set_disable(bool value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool disable_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class ReportResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.ReportResponse) */ {
 public:
  ReportResponse();
  virtual ~ReportResponse();

  ReportResponse(const ReportResponse& from);

  inline ReportResponse& operator=(const ReportResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportResponse& default_instance();

  void Swap(ReportResponse* other);

  // implements Message ----------------------------------------------

  inline ReportResponse* New() const { return New(NULL); }

  ReportResponse* New(::google::protobuf::Arena* arena) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lightstep.collector.Command commands = 1;
  int commands_size() const;
  void clear_commands();
  static const int kCommandsFieldNumber = 1;
  const ::lightstep::collector::Command& commands(int index) const;
  ::lightstep::collector::Command* mutable_commands(int index);
  ::lightstep::collector::Command* add_commands();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >*
      mutable_commands();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >&
      commands() const;

  // optional .google.protobuf.Timestamp receive_timestamp = 2;
  bool has_receive_timestamp() const;
  void clear_receive_timestamp();
  static const int kReceiveTimestampFieldNumber = 2;
  const ::google::protobuf::Timestamp& receive_timestamp() const;
  ::google::protobuf::Timestamp* mutable_receive_timestamp();
  ::google::protobuf::Timestamp* release_receive_timestamp();
  void set_allocated_receive_timestamp(::google::protobuf::Timestamp* receive_timestamp);

  // optional .google.protobuf.Timestamp transmit_timestamp = 3;
  bool has_transmit_timestamp() const;
  void clear_transmit_timestamp();
  static const int kTransmitTimestampFieldNumber = 3;
  const ::google::protobuf::Timestamp& transmit_timestamp() const;
  ::google::protobuf::Timestamp* mutable_transmit_timestamp();
  ::google::protobuf::Timestamp* release_transmit_timestamp();
  void set_allocated_transmit_timestamp(::google::protobuf::Timestamp* transmit_timestamp);

  // repeated string errors = 4;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 4;
  const ::std::string& errors(int index) const;
  ::std::string* mutable_errors(int index);
  void set_errors(int index, const ::std::string& value);
  void set_errors(int index, const char* value);
  void set_errors(int index, const char* value, size_t size);
  ::std::string* add_errors();
  void add_errors(const ::std::string& value);
  void add_errors(const char* value);
  void add_errors(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& errors() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_errors();

  // @@protoc_insertion_point(class_scope:lightstep.collector.ReportResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command > commands_;
  ::google::protobuf::Timestamp* receive_timestamp_;
  ::google::protobuf::Timestamp* transmit_timestamp_;
  ::google::protobuf::RepeatedPtrField< ::std::string> errors_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_collector_2eproto();
  friend void protobuf_AssignDesc_collector_2eproto();
  friend void protobuf_ShutdownFile_collector_2eproto();

  void InitAsDefaultInstance();
  static ReportResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SpanContext

// optional uint64 trace_id = 1;
inline void SpanContext::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SpanContext::trace_id() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.SpanContext.trace_id)
  return trace_id_;
}
inline void SpanContext::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.SpanContext.trace_id)
}

// optional uint64 span_id = 2;
inline void SpanContext::clear_span_id() {
  span_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SpanContext::span_id() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.SpanContext.span_id)
  return span_id_;
}
inline void SpanContext::set_span_id(::google::protobuf::uint64 value) {
  
  span_id_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.SpanContext.span_id)
}

// map<string, string> baggage = 3;
inline int SpanContext::baggage_size() const {
  return baggage_.size();
}
inline void SpanContext::clear_baggage() {
  baggage_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
SpanContext::baggage() const {
  // @@protoc_insertion_point(field_map:lightstep.collector.SpanContext.baggage)
  return baggage_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
SpanContext::mutable_baggage() {
  // @@protoc_insertion_point(field_mutable_map:lightstep.collector.SpanContext.baggage)
  return baggage_.MutableMap();
}

// -------------------------------------------------------------------

// KeyValue

// optional string key = 1;
inline void KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.key)
}
inline void KeyValue::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.KeyValue.key)
}
inline void KeyValue::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.KeyValue.key)
}
inline ::std::string* KeyValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.KeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:lightstep.collector.KeyValue.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.KeyValue.key)
}

// optional string string_value = 2;
inline bool KeyValue::has_string_value() const {
  return value_case() == kStringValue;
}
inline void KeyValue::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void KeyValue::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& KeyValue::string_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void KeyValue::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.string_value)
}
inline void KeyValue::set_string_value(const char* value) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.KeyValue.string_value)
}
inline void KeyValue::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.KeyValue.string_value)
}
inline ::std::string* KeyValue::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.KeyValue.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_string_value() {
  // @@protoc_insertion_point(field_release:lightstep.collector.KeyValue.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void KeyValue::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (string_value != NULL) {
    set_has_string_value();
    value_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.KeyValue.string_value)
}

// optional int64 int_value = 3;
inline bool KeyValue::has_int_value() const {
  return value_case() == kIntValue;
}
inline void KeyValue::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void KeyValue::clear_int_value() {
  if (has_int_value()) {
    value_.int_value_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 KeyValue::int_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.int_value)
  if (has_int_value()) {
    return value_.int_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void KeyValue::set_int_value(::google::protobuf::int64 value) {
  if (!has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.int_value)
}

// optional double double_value = 4;
inline bool KeyValue::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void KeyValue::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void KeyValue::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double KeyValue::double_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void KeyValue::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.double_value)
}

// optional bool bool_value = 5;
inline bool KeyValue::has_bool_value() const {
  return value_case() == kBoolValue;
}
inline void KeyValue::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void KeyValue::clear_bool_value() {
  if (has_bool_value()) {
    value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool KeyValue::bool_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.bool_value)
  if (has_bool_value()) {
    return value_.bool_value_;
  }
  return false;
}
inline void KeyValue::set_bool_value(bool value) {
  if (!has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  value_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.bool_value)
}

// optional string json_value = 6;
inline bool KeyValue::has_json_value() const {
  return value_case() == kJsonValue;
}
inline void KeyValue::set_has_json_value() {
  _oneof_case_[0] = kJsonValue;
}
inline void KeyValue::clear_json_value() {
  if (has_json_value()) {
    value_.json_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& KeyValue::json_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.json_value)
  if (has_json_value()) {
    return value_.json_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void KeyValue::set_json_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.json_value)
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.json_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.json_value)
}
inline void KeyValue::set_json_value(const char* value) {
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.json_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.KeyValue.json_value)
}
inline void KeyValue::set_json_value(const char* value, size_t size) {
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.json_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.KeyValue.json_value)
}
inline ::std::string* KeyValue::mutable_json_value() {
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.KeyValue.json_value)
  return value_.json_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_json_value() {
  // @@protoc_insertion_point(field_release:lightstep.collector.KeyValue.json_value)
  if (has_json_value()) {
    clear_has_value();
    return value_.json_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void KeyValue::set_allocated_json_value(::std::string* json_value) {
  if (!has_json_value()) {
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (json_value != NULL) {
    set_has_json_value();
    value_.json_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        json_value);
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.KeyValue.json_value)
}

inline bool KeyValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void KeyValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline KeyValue::ValueCase KeyValue::value_case() const {
  return KeyValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Log

// optional .google.protobuf.Timestamp timestamp = 1;
inline bool Log::has_timestamp() const {
  return !_is_default_instance_ && timestamp_ != NULL;
}
inline void Log::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Log::timestamp() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Log.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::google::protobuf::Timestamp* Log::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Log.timestamp)
  return timestamp_;
}
inline ::google::protobuf::Timestamp* Log::release_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Log.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void Log::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  delete timestamp_;
  if (timestamp != NULL && timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_timestamp = new ::google::protobuf::Timestamp;
    new_timestamp->CopyFrom(*timestamp);
    timestamp = new_timestamp;
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Log.timestamp)
}

// repeated .lightstep.collector.KeyValue keyvalues = 2;
inline int Log::keyvalues_size() const {
  return keyvalues_.size();
}
inline void Log::clear_keyvalues() {
  keyvalues_.Clear();
}
inline const ::lightstep::collector::KeyValue& Log::keyvalues(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Log.keyvalues)
  return keyvalues_.Get(index);
}
inline ::lightstep::collector::KeyValue* Log::mutable_keyvalues(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Log.keyvalues)
  return keyvalues_.Mutable(index);
}
inline ::lightstep::collector::KeyValue* Log::add_keyvalues() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Log.keyvalues)
  return keyvalues_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
Log::mutable_keyvalues() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Log.keyvalues)
  return &keyvalues_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
Log::keyvalues() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Log.keyvalues)
  return keyvalues_;
}

// -------------------------------------------------------------------

// Reference

// optional .lightstep.collector.Reference.Relationship relationship = 1;
inline void Reference::clear_relationship() {
  relationship_ = 0;
}
inline ::lightstep::collector::Reference_Relationship Reference::relationship() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Reference.relationship)
  return static_cast< ::lightstep::collector::Reference_Relationship >(relationship_);
}
inline void Reference::set_relationship(::lightstep::collector::Reference_Relationship value) {
  
  relationship_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Reference.relationship)
}

// optional .lightstep.collector.SpanContext span_context = 2;
inline bool Reference::has_span_context() const {
  return !_is_default_instance_ && span_context_ != NULL;
}
inline void Reference::clear_span_context() {
  if (GetArenaNoVirtual() == NULL && span_context_ != NULL) delete span_context_;
  span_context_ = NULL;
}
inline const ::lightstep::collector::SpanContext& Reference::span_context() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Reference.span_context)
  return span_context_ != NULL ? *span_context_ : *default_instance_->span_context_;
}
inline ::lightstep::collector::SpanContext* Reference::mutable_span_context() {
  
  if (span_context_ == NULL) {
    span_context_ = new ::lightstep::collector::SpanContext;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Reference.span_context)
  return span_context_;
}
inline ::lightstep::collector::SpanContext* Reference::release_span_context() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Reference.span_context)
  
  ::lightstep::collector::SpanContext* temp = span_context_;
  span_context_ = NULL;
  return temp;
}
inline void Reference::set_allocated_span_context(::lightstep::collector::SpanContext* span_context) {
  delete span_context_;
  span_context_ = span_context;
  if (span_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Reference.span_context)
}

// -------------------------------------------------------------------

// Span

// optional .lightstep.collector.SpanContext span_context = 1;
inline bool Span::has_span_context() const {
  return !_is_default_instance_ && span_context_ != NULL;
}
inline void Span::clear_span_context() {
  if (GetArenaNoVirtual() == NULL && span_context_ != NULL) delete span_context_;
  span_context_ = NULL;
}
inline const ::lightstep::collector::SpanContext& Span::span_context() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.span_context)
  return span_context_ != NULL ? *span_context_ : *default_instance_->span_context_;
}
inline ::lightstep::collector::SpanContext* Span::mutable_span_context() {
  
  if (span_context_ == NULL) {
    span_context_ = new ::lightstep::collector::SpanContext;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.span_context)
  return span_context_;
}
inline ::lightstep::collector::SpanContext* Span::release_span_context() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Span.span_context)
  
  ::lightstep::collector::SpanContext* temp = span_context_;
  span_context_ = NULL;
  return temp;
}
inline void Span::set_allocated_span_context(::lightstep::collector::SpanContext* span_context) {
  delete span_context_;
  span_context_ = span_context;
  if (span_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Span.span_context)
}

// optional string operation_name = 2;
inline void Span::clear_operation_name() {
  operation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::operation_name() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.operation_name)
  return operation_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_operation_name(const ::std::string& value) {
  
  operation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.Span.operation_name)
}
inline void Span::set_operation_name(const char* value) {
  
  operation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.Span.operation_name)
}
inline void Span::set_operation_name(const char* value, size_t size) {
  
  operation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.Span.operation_name)
}
inline ::std::string* Span::mutable_operation_name() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.operation_name)
  return operation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_operation_name() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Span.operation_name)
  
  return operation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_operation_name(::std::string* operation_name) {
  if (operation_name != NULL) {
    
  } else {
    
  }
  operation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation_name);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Span.operation_name)
}

// repeated .lightstep.collector.Reference references = 3;
inline int Span::references_size() const {
  return references_.size();
}
inline void Span::clear_references() {
  references_.Clear();
}
inline const ::lightstep::collector::Reference& Span::references(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.references)
  return references_.Get(index);
}
inline ::lightstep::collector::Reference* Span::mutable_references(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.references)
  return references_.Mutable(index);
}
inline ::lightstep::collector::Reference* Span::add_references() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Span.references)
  return references_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >*
Span::mutable_references() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Span.references)
  return &references_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >&
Span::references() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Span.references)
  return references_;
}

// optional .google.protobuf.Timestamp start_timestamp = 4;
inline bool Span::has_start_timestamp() const {
  return !_is_default_instance_ && start_timestamp_ != NULL;
}
inline void Span::clear_start_timestamp() {
  if (GetArenaNoVirtual() == NULL && start_timestamp_ != NULL) delete start_timestamp_;
  start_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Span::start_timestamp() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.start_timestamp)
  return start_timestamp_ != NULL ? *start_timestamp_ : *default_instance_->start_timestamp_;
}
inline ::google::protobuf::Timestamp* Span::mutable_start_timestamp() {
  
  if (start_timestamp_ == NULL) {
    start_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.start_timestamp)
  return start_timestamp_;
}
inline ::google::protobuf::Timestamp* Span::release_start_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Span.start_timestamp)
  
  ::google::protobuf::Timestamp* temp = start_timestamp_;
  start_timestamp_ = NULL;
  return temp;
}
inline void Span::set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp) {
  delete start_timestamp_;
  if (start_timestamp != NULL && start_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_start_timestamp = new ::google::protobuf::Timestamp;
    new_start_timestamp->CopyFrom(*start_timestamp);
    start_timestamp = new_start_timestamp;
  }
  start_timestamp_ = start_timestamp;
  if (start_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Span.start_timestamp)
}

// optional uint64 duration_micros = 5;
inline void Span::clear_duration_micros() {
  duration_micros_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span::duration_micros() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.duration_micros)
  return duration_micros_;
}
inline void Span::set_duration_micros(::google::protobuf::uint64 value) {
  
  duration_micros_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Span.duration_micros)
}

// repeated .lightstep.collector.KeyValue tags = 6;
inline int Span::tags_size() const {
  return tags_.size();
}
inline void Span::clear_tags() {
  tags_.Clear();
}
inline const ::lightstep::collector::KeyValue& Span::tags(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.tags)
  return tags_.Get(index);
}
inline ::lightstep::collector::KeyValue* Span::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.tags)
  return tags_.Mutable(index);
}
inline ::lightstep::collector::KeyValue* Span::add_tags() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Span.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
Span::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Span.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
Span::tags() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Span.tags)
  return tags_;
}

// repeated .lightstep.collector.Log logs = 7;
inline int Span::logs_size() const {
  return logs_.size();
}
inline void Span::clear_logs() {
  logs_.Clear();
}
inline const ::lightstep::collector::Log& Span::logs(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.logs)
  return logs_.Get(index);
}
inline ::lightstep::collector::Log* Span::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.logs)
  return logs_.Mutable(index);
}
inline ::lightstep::collector::Log* Span::add_logs() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Span.logs)
  return logs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
Span::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Span.logs)
  return &logs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
Span::logs() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Span.logs)
  return logs_;
}

// -------------------------------------------------------------------

// Tracer

// optional uint64 tracer_id = 1;
inline void Tracer::clear_tracer_id() {
  tracer_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Tracer::tracer_id() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Tracer.tracer_id)
  return tracer_id_;
}
inline void Tracer::set_tracer_id(::google::protobuf::uint64 value) {
  
  tracer_id_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Tracer.tracer_id)
}

// repeated .lightstep.collector.KeyValue tags = 4;
inline int Tracer::tags_size() const {
  return tags_.size();
}
inline void Tracer::clear_tags() {
  tags_.Clear();
}
inline const ::lightstep::collector::KeyValue& Tracer::tags(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Tracer.tags)
  return tags_.Get(index);
}
inline ::lightstep::collector::KeyValue* Tracer::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Tracer.tags)
  return tags_.Mutable(index);
}
inline ::lightstep::collector::KeyValue* Tracer::add_tags() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Tracer.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
Tracer::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Tracer.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
Tracer::tags() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Tracer.tags)
  return tags_;
}

// -------------------------------------------------------------------

// MetricsSample

// optional string name = 1;
inline void MetricsSample::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MetricsSample::name() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.MetricsSample.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetricsSample::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.MetricsSample.name)
}
inline void MetricsSample::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.MetricsSample.name)
}
inline void MetricsSample::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.MetricsSample.name)
}
inline ::std::string* MetricsSample::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.MetricsSample.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetricsSample::release_name() {
  // @@protoc_insertion_point(field_release:lightstep.collector.MetricsSample.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetricsSample::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.MetricsSample.name)
}

// optional int64 int_value = 2;
inline bool MetricsSample::has_int_value() const {
  return value_case() == kIntValue;
}
inline void MetricsSample::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void MetricsSample::clear_int_value() {
  if (has_int_value()) {
    value_.int_value_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 MetricsSample::int_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.MetricsSample.int_value)
  if (has_int_value()) {
    return value_.int_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void MetricsSample::set_int_value(::google::protobuf::int64 value) {
  if (!has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.MetricsSample.int_value)
}

// optional double double_value = 3;
inline bool MetricsSample::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void MetricsSample::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void MetricsSample::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double MetricsSample::double_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.MetricsSample.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void MetricsSample::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.MetricsSample.double_value)
}

inline bool MetricsSample::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void MetricsSample::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline MetricsSample::ValueCase MetricsSample::value_case() const {
  return MetricsSample::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalMetrics

// optional .google.protobuf.Timestamp start_timestamp = 1;
inline bool InternalMetrics::has_start_timestamp() const {
  return !_is_default_instance_ && start_timestamp_ != NULL;
}
inline void InternalMetrics::clear_start_timestamp() {
  if (GetArenaNoVirtual() == NULL && start_timestamp_ != NULL) delete start_timestamp_;
  start_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& InternalMetrics::start_timestamp() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.start_timestamp)
  return start_timestamp_ != NULL ? *start_timestamp_ : *default_instance_->start_timestamp_;
}
inline ::google::protobuf::Timestamp* InternalMetrics::mutable_start_timestamp() {
  
  if (start_timestamp_ == NULL) {
    start_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.start_timestamp)
  return start_timestamp_;
}
inline ::google::protobuf::Timestamp* InternalMetrics::release_start_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.InternalMetrics.start_timestamp)
  
  ::google::protobuf::Timestamp* temp = start_timestamp_;
  start_timestamp_ = NULL;
  return temp;
}
inline void InternalMetrics::set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp) {
  delete start_timestamp_;
  if (start_timestamp != NULL && start_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_start_timestamp = new ::google::protobuf::Timestamp;
    new_start_timestamp->CopyFrom(*start_timestamp);
    start_timestamp = new_start_timestamp;
  }
  start_timestamp_ = start_timestamp;
  if (start_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.InternalMetrics.start_timestamp)
}

// optional uint64 duration_micros = 2;
inline void InternalMetrics::clear_duration_micros() {
  duration_micros_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InternalMetrics::duration_micros() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.duration_micros)
  return duration_micros_;
}
inline void InternalMetrics::set_duration_micros(::google::protobuf::uint64 value) {
  
  duration_micros_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.InternalMetrics.duration_micros)
}

// repeated .lightstep.collector.Log logs = 3;
inline int InternalMetrics::logs_size() const {
  return logs_.size();
}
inline void InternalMetrics::clear_logs() {
  logs_.Clear();
}
inline const ::lightstep::collector::Log& InternalMetrics::logs(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.logs)
  return logs_.Get(index);
}
inline ::lightstep::collector::Log* InternalMetrics::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.logs)
  return logs_.Mutable(index);
}
inline ::lightstep::collector::Log* InternalMetrics::add_logs() {
  // @@protoc_insertion_point(field_add:lightstep.collector.InternalMetrics.logs)
  return logs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
InternalMetrics::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.InternalMetrics.logs)
  return &logs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
InternalMetrics::logs() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.InternalMetrics.logs)
  return logs_;
}

// repeated .lightstep.collector.MetricsSample counts = 4;
inline int InternalMetrics::counts_size() const {
  return counts_.size();
}
inline void InternalMetrics::clear_counts() {
  counts_.Clear();
}
inline const ::lightstep::collector::MetricsSample& InternalMetrics::counts(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.counts)
  return counts_.Get(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::mutable_counts(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.counts)
  return counts_.Mutable(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::add_counts() {
  // @@protoc_insertion_point(field_add:lightstep.collector.InternalMetrics.counts)
  return counts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
InternalMetrics::mutable_counts() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.InternalMetrics.counts)
  return &counts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
InternalMetrics::counts() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.InternalMetrics.counts)
  return counts_;
}

// repeated .lightstep.collector.MetricsSample gauges = 5;
inline int InternalMetrics::gauges_size() const {
  return gauges_.size();
}
inline void InternalMetrics::clear_gauges() {
  gauges_.Clear();
}
inline const ::lightstep::collector::MetricsSample& InternalMetrics::gauges(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.gauges)
  return gauges_.Get(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::mutable_gauges(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.gauges)
  return gauges_.Mutable(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::add_gauges() {
  // @@protoc_insertion_point(field_add:lightstep.collector.InternalMetrics.gauges)
  return gauges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
InternalMetrics::mutable_gauges() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.InternalMetrics.gauges)
  return &gauges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
InternalMetrics::gauges() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.InternalMetrics.gauges)
  return gauges_;
}

// -------------------------------------------------------------------

// Auth

// optional string access_token = 1;
inline void Auth::clear_access_token() {
  access_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::access_token() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Auth.access_token)
  return access_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_access_token(const ::std::string& value) {
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.Auth.access_token)
}
inline void Auth::set_access_token(const char* value) {
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.Auth.access_token)
}
inline void Auth::set_access_token(const char* value, size_t size) {
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.Auth.access_token)
}
inline ::std::string* Auth::mutable_access_token() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Auth.access_token)
  return access_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_access_token() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Auth.access_token)
  
  return access_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_access_token(::std::string* access_token) {
  if (access_token != NULL) {
    
  } else {
    
  }
  access_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), access_token);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Auth.access_token)
}

// -------------------------------------------------------------------

// ReportRequest

// optional .lightstep.collector.Tracer tracer = 1;
inline bool ReportRequest::has_tracer() const {
  return !_is_default_instance_ && tracer_ != NULL;
}
inline void ReportRequest::clear_tracer() {
  if (GetArenaNoVirtual() == NULL && tracer_ != NULL) delete tracer_;
  tracer_ = NULL;
}
inline const ::lightstep::collector::Tracer& ReportRequest::tracer() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.tracer)
  return tracer_ != NULL ? *tracer_ : *default_instance_->tracer_;
}
inline ::lightstep::collector::Tracer* ReportRequest::mutable_tracer() {
  
  if (tracer_ == NULL) {
    tracer_ = new ::lightstep::collector::Tracer;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.tracer)
  return tracer_;
}
inline ::lightstep::collector::Tracer* ReportRequest::release_tracer() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportRequest.tracer)
  
  ::lightstep::collector::Tracer* temp = tracer_;
  tracer_ = NULL;
  return temp;
}
inline void ReportRequest::set_allocated_tracer(::lightstep::collector::Tracer* tracer) {
  delete tracer_;
  tracer_ = tracer;
  if (tracer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportRequest.tracer)
}

// optional .lightstep.collector.Auth auth = 2;
inline bool ReportRequest::has_auth() const {
  return !_is_default_instance_ && auth_ != NULL;
}
inline void ReportRequest::clear_auth() {
  if (GetArenaNoVirtual() == NULL && auth_ != NULL) delete auth_;
  auth_ = NULL;
}
inline const ::lightstep::collector::Auth& ReportRequest::auth() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.auth)
  return auth_ != NULL ? *auth_ : *default_instance_->auth_;
}
inline ::lightstep::collector::Auth* ReportRequest::mutable_auth() {
  
  if (auth_ == NULL) {
    auth_ = new ::lightstep::collector::Auth;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.auth)
  return auth_;
}
inline ::lightstep::collector::Auth* ReportRequest::release_auth() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportRequest.auth)
  
  ::lightstep::collector::Auth* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline void ReportRequest::set_allocated_auth(::lightstep::collector::Auth* auth) {
  delete auth_;
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportRequest.auth)
}

// repeated .lightstep.collector.Span spans = 3;
inline int ReportRequest::spans_size() const {
  return spans_.size();
}
inline void ReportRequest::clear_spans() {
  spans_.Clear();
}
inline const ::lightstep::collector::Span& ReportRequest::spans(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.spans)
  return spans_.Get(index);
}
inline ::lightstep::collector::Span* ReportRequest::mutable_spans(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.spans)
  return spans_.Mutable(index);
}
inline ::lightstep::collector::Span* ReportRequest::add_spans() {
  // @@protoc_insertion_point(field_add:lightstep.collector.ReportRequest.spans)
  return spans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >*
ReportRequest::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.ReportRequest.spans)
  return &spans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >&
ReportRequest::spans() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.ReportRequest.spans)
  return spans_;
}

// optional uint32 timestamp_offset_micros = 5;
inline void ReportRequest::clear_timestamp_offset_micros() {
  timestamp_offset_micros_ = 0u;
}
inline ::google::protobuf::uint32 ReportRequest::timestamp_offset_micros() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.timestamp_offset_micros)
  return timestamp_offset_micros_;
}
inline void ReportRequest::set_timestamp_offset_micros(::google::protobuf::uint32 value) {
  
  timestamp_offset_micros_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.ReportRequest.timestamp_offset_micros)
}

// optional .lightstep.collector.InternalMetrics internal_metrics = 6;
inline bool ReportRequest::has_internal_metrics() const {
  return !_is_default_instance_ && internal_metrics_ != NULL;
}
inline void ReportRequest::clear_internal_metrics() {
  if (GetArenaNoVirtual() == NULL && internal_metrics_ != NULL) delete internal_metrics_;
  internal_metrics_ = NULL;
}
inline const ::lightstep::collector::InternalMetrics& ReportRequest::internal_metrics() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.internal_metrics)
  return internal_metrics_ != NULL ? *internal_metrics_ : *default_instance_->internal_metrics_;
}
inline ::lightstep::collector::InternalMetrics* ReportRequest::mutable_internal_metrics() {
  
  if (internal_metrics_ == NULL) {
    internal_metrics_ = new ::lightstep::collector::InternalMetrics;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.internal_metrics)
  return internal_metrics_;
}
inline ::lightstep::collector::InternalMetrics* ReportRequest::release_internal_metrics() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportRequest.internal_metrics)
  
  ::lightstep::collector::InternalMetrics* temp = internal_metrics_;
  internal_metrics_ = NULL;
  return temp;
}
inline void ReportRequest::set_allocated_internal_metrics(::lightstep::collector::InternalMetrics* internal_metrics) {
  delete internal_metrics_;
  internal_metrics_ = internal_metrics;
  if (internal_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportRequest.internal_metrics)
}

// -------------------------------------------------------------------

// Command

// optional bool disable = 1;
inline void Command::clear_disable() {
  disable_ = false;
}
inline bool Command::disable() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Command.disable)
  return disable_;
}
inline void Command::set_disable(bool value) {
  
  disable_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Command.disable)
}

// -------------------------------------------------------------------

// ReportResponse

// repeated .lightstep.collector.Command commands = 1;
inline int ReportResponse::commands_size() const {
  return commands_.size();
}
inline void ReportResponse::clear_commands() {
  commands_.Clear();
}
inline const ::lightstep::collector::Command& ReportResponse::commands(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.commands)
  return commands_.Get(index);
}
inline ::lightstep::collector::Command* ReportResponse::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.commands)
  return commands_.Mutable(index);
}
inline ::lightstep::collector::Command* ReportResponse::add_commands() {
  // @@protoc_insertion_point(field_add:lightstep.collector.ReportResponse.commands)
  return commands_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >*
ReportResponse::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.ReportResponse.commands)
  return &commands_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >&
ReportResponse::commands() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.ReportResponse.commands)
  return commands_;
}

// optional .google.protobuf.Timestamp receive_timestamp = 2;
inline bool ReportResponse::has_receive_timestamp() const {
  return !_is_default_instance_ && receive_timestamp_ != NULL;
}
inline void ReportResponse::clear_receive_timestamp() {
  if (GetArenaNoVirtual() == NULL && receive_timestamp_ != NULL) delete receive_timestamp_;
  receive_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& ReportResponse::receive_timestamp() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.receive_timestamp)
  return receive_timestamp_ != NULL ? *receive_timestamp_ : *default_instance_->receive_timestamp_;
}
inline ::google::protobuf::Timestamp* ReportResponse::mutable_receive_timestamp() {
  
  if (receive_timestamp_ == NULL) {
    receive_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.receive_timestamp)
  return receive_timestamp_;
}
inline ::google::protobuf::Timestamp* ReportResponse::release_receive_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportResponse.receive_timestamp)
  
  ::google::protobuf::Timestamp* temp = receive_timestamp_;
  receive_timestamp_ = NULL;
  return temp;
}
inline void ReportResponse::set_allocated_receive_timestamp(::google::protobuf::Timestamp* receive_timestamp) {
  delete receive_timestamp_;
  if (receive_timestamp != NULL && receive_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_receive_timestamp = new ::google::protobuf::Timestamp;
    new_receive_timestamp->CopyFrom(*receive_timestamp);
    receive_timestamp = new_receive_timestamp;
  }
  receive_timestamp_ = receive_timestamp;
  if (receive_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportResponse.receive_timestamp)
}

// optional .google.protobuf.Timestamp transmit_timestamp = 3;
inline bool ReportResponse::has_transmit_timestamp() const {
  return !_is_default_instance_ && transmit_timestamp_ != NULL;
}
inline void ReportResponse::clear_transmit_timestamp() {
  if (GetArenaNoVirtual() == NULL && transmit_timestamp_ != NULL) delete transmit_timestamp_;
  transmit_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& ReportResponse::transmit_timestamp() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.transmit_timestamp)
  return transmit_timestamp_ != NULL ? *transmit_timestamp_ : *default_instance_->transmit_timestamp_;
}
inline ::google::protobuf::Timestamp* ReportResponse::mutable_transmit_timestamp() {
  
  if (transmit_timestamp_ == NULL) {
    transmit_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.transmit_timestamp)
  return transmit_timestamp_;
}
inline ::google::protobuf::Timestamp* ReportResponse::release_transmit_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportResponse.transmit_timestamp)
  
  ::google::protobuf::Timestamp* temp = transmit_timestamp_;
  transmit_timestamp_ = NULL;
  return temp;
}
inline void ReportResponse::set_allocated_transmit_timestamp(::google::protobuf::Timestamp* transmit_timestamp) {
  delete transmit_timestamp_;
  if (transmit_timestamp != NULL && transmit_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_transmit_timestamp = new ::google::protobuf::Timestamp;
    new_transmit_timestamp->CopyFrom(*transmit_timestamp);
    transmit_timestamp = new_transmit_timestamp;
  }
  transmit_timestamp_ = transmit_timestamp;
  if (transmit_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportResponse.transmit_timestamp)
}

// repeated string errors = 4;
inline int ReportResponse::errors_size() const {
  return errors_.size();
}
inline void ReportResponse::clear_errors() {
  errors_.Clear();
}
inline const ::std::string& ReportResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.errors)
  return errors_.Get(index);
}
inline ::std::string* ReportResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.errors)
  return errors_.Mutable(index);
}
inline void ReportResponse::set_errors(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.ReportResponse.errors)
  errors_.Mutable(index)->assign(value);
}
inline void ReportResponse::set_errors(int index, const char* value) {
  errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:lightstep.collector.ReportResponse.errors)
}
inline void ReportResponse::set_errors(int index, const char* value, size_t size) {
  errors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.ReportResponse.errors)
}
inline ::std::string* ReportResponse::add_errors() {
  // @@protoc_insertion_point(field_add_mutable:lightstep.collector.ReportResponse.errors)
  return errors_.Add();
}
inline void ReportResponse::add_errors(const ::std::string& value) {
  errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:lightstep.collector.ReportResponse.errors)
}
inline void ReportResponse::add_errors(const char* value) {
  errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:lightstep.collector.ReportResponse.errors)
}
inline void ReportResponse::add_errors(const char* value, size_t size) {
  errors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:lightstep.collector.ReportResponse.errors)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReportResponse::errors() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.ReportResponse.errors)
  return errors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReportResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.ReportResponse.errors)
  return &errors_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace collector
}  // namespace lightstep

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lightstep::collector::Reference_Relationship> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lightstep::collector::Reference_Relationship>() {
  return ::lightstep::collector::Reference_Relationship_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_collector_2eproto__INCLUDED
